-- ============================================================================
-- William.ai Initial Database Schema
-- Migration: 001_initial_schema.sql
-- 
-- SECURITY NOTES:
-- - RLS is NOT enabled in this migration (Phase 2)
-- - All tables use UUID primary keys to prevent enumeration attacks
-- - Foreign keys with CASCADE ensure referential integrity
-- - CHECK constraints validate data at database level
-- - SECURITY DEFINER functions run with elevated privileges only for triggers
-- ============================================================================

-- ============================================================================
-- TABLE 1: profiles
-- Extends Supabase auth.users with application-specific user data
-- ============================================================================

CREATE TABLE public.profiles (
  -- Primary key references auth.users - ensures 1:1 relationship
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- User email (copied from auth.users for convenience, validated)
  email TEXT NOT NULL,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- Usage tracking
  total_posts_generated INTEGER DEFAULT 0 NOT NULL,
  total_api_cost_usd DECIMAL(10, 4) DEFAULT 0 NOT NULL,
  
  -- CONSTRAINTS
  -- Email format validation (RFC 5322 simplified)
  CONSTRAINT valid_email CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  -- Prevent negative values
  CONSTRAINT non_negative_posts CHECK (total_posts_generated >= 0),
  CONSTRAINT non_negative_cost CHECK (total_api_cost_usd >= 0)
);

-- Add comment for documentation
COMMENT ON TABLE public.profiles IS 'User profiles extending Supabase auth.users with app-specific data';
COMMENT ON COLUMN public.profiles.total_posts_generated IS 'Running count of posts generated by this user';
COMMENT ON COLUMN public.profiles.total_api_cost_usd IS 'Running total of API costs incurred by this user';


-- ============================================================================
-- TABLE 2: voice_profiles
-- Stores user voice configurations with rules, reference posts, and branding
-- ============================================================================

CREATE TABLE public.voice_profiles (
  -- Auto-generated UUID primary key
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Owner reference (required, cascades on user deletion)
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Voice profile name
  name TEXT NOT NULL,
  
  -- Voice rules (JSONB for flexibility)
  -- Structure: { sentencePatterns: [], forbiddenWords: [], signaturePhrases: [], rhythmPreferences: {}, formattingRules: {} }
  rules JSONB NOT NULL DEFAULT '{}',
  
  -- Reference posts for voice matching
  -- Structure: [{ content: "", platform: "linkedin"|"twitter", engagement: 0, url?: "" }]
  top_posts JSONB NOT NULL DEFAULT '[]',
  
  -- Brand colors for carousel generation
  -- Structure: { primary: "#hex", secondary: "#hex", accent: "#hex" }
  brand_colors JSONB NOT NULL DEFAULT '{"primary":"#000000","secondary":"#ffffff","accent":"#0066cc"}',
  
  -- Analytics stats (optional)
  -- Structure: { totalPosts: 0, avgQualityScore: 0, lastUsed: "ISO date" }
  stats JSONB DEFAULT NULL,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- CONSTRAINTS
  -- Name must be 1-100 characters
  CONSTRAINT name_not_empty CHECK (char_length(name) >= 1 AND char_length(name) <= 100),
  
  -- Minimum 20 total rules across sentencePatterns, forbiddenWords, and signaturePhrases
  -- This ensures the voice profile has enough data for accurate voice matching
  CONSTRAINT rules_min_items CHECK (
    jsonb_array_length(COALESCE(rules->'sentencePatterns', '[]'::jsonb)) +
    jsonb_array_length(COALESCE(rules->'forbiddenWords', '[]'::jsonb)) +
    jsonb_array_length(COALESCE(rules->'signaturePhrases', '[]'::jsonb)) >= 20
  )
);

-- INDEX: Optimize queries filtering by user_id (most common access pattern)
CREATE INDEX idx_voice_profiles_user_id ON public.voice_profiles(user_id);

-- Add comments for documentation
COMMENT ON TABLE public.voice_profiles IS 'Voice profiles containing writing style rules and preferences';
COMMENT ON COLUMN public.voice_profiles.rules IS 'JSONB containing sentencePatterns, forbiddenWords, signaturePhrases, rhythmPreferences, formattingRules';
COMMENT ON COLUMN public.voice_profiles.top_posts IS 'Array of reference posts for voice matching with content, platform, engagement, url';
COMMENT ON COLUMN public.voice_profiles.brand_colors IS 'Brand colors for carousel generation: primary, secondary, accent (hex)';


-- ============================================================================
-- TABLE 3: generated_posts
-- Stores AI-generated content with full pipeline data and quality metrics
-- ============================================================================

CREATE TABLE public.generated_posts (
  -- Auto-generated UUID primary key
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Owner reference (required, cascades on user deletion)
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Voice profile used for generation (required, cascades on profile deletion)
  voice_profile_id UUID NOT NULL REFERENCES public.voice_profiles(id) ON DELETE CASCADE,
  
  -- Interview data (user's answers and metadata)
  -- Structure: { id, flowType, voiceModeId, voiceProfileId, createdAt, answers: {q1..q6}, extractedInsight?, platform, targetAudience? }
  interview_data JSONB NOT NULL,
  
  -- Pipeline stages data (full generation history)
  -- Structure: { initialVersions, selectedVersion, selectionReasoning, refinedVersion, refinementChanges, hookOptions, selectedHook, hookOptimizedVersion, personalityVersion, injectedElements, finalVersion }
  pipeline_data JSONB NOT NULL,
  
  -- Final outputs for different platforms
  -- Structure: { linkedin: { post, characterCount, hashtagCount }, twitter: { thread, characterCounts } }
  outputs JSONB NOT NULL,
  
  -- Quality metrics
  quality_score INTEGER NOT NULL,
  tokens_used INTEGER DEFAULT 0 NOT NULL,
  api_cost_usd DECIMAL(10, 6) DEFAULT 0 NOT NULL,
  
  -- Workflow status
  status TEXT DEFAULT 'generating' NOT NULL,
  failure_reason TEXT,
  exported_at TIMESTAMPTZ,
  scheduled_for TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  
  -- CONSTRAINTS
  -- Quality score must be 0-100
  CONSTRAINT quality_score_range CHECK (quality_score >= 0 AND quality_score <= 100),
  -- Status must be one of the valid enum values
  CONSTRAINT valid_status CHECK (status IN ('generating', 'passed', 'failed', 'exported', 'scheduled')),
  -- Prevent negative values
  CONSTRAINT non_negative_tokens CHECK (tokens_used >= 0),
  CONSTRAINT non_negative_api_cost CHECK (api_cost_usd >= 0)
);

-- INDEXES: Optimize common query patterns
-- Primary access pattern: get posts by user
CREATE INDEX idx_generated_posts_user_id ON public.generated_posts(user_id);
-- Filter posts by voice profile
CREATE INDEX idx_generated_posts_voice_profile_id ON public.generated_posts(voice_profile_id);
-- Sort by creation date (descending for "recent first")
CREATE INDEX idx_generated_posts_created_at ON public.generated_posts(created_at DESC);
-- Composite index for dashboard queries: user's posts sorted by date
CREATE INDEX idx_generated_posts_user_created ON public.generated_posts(user_id, created_at DESC);

-- Add comments for documentation
COMMENT ON TABLE public.generated_posts IS 'AI-generated posts with full pipeline data, quality metrics, and platform outputs';
COMMENT ON COLUMN public.generated_posts.interview_data IS 'User interview responses and extracted insights';
COMMENT ON COLUMN public.generated_posts.pipeline_data IS 'Full generation pipeline history including all intermediate versions';
COMMENT ON COLUMN public.generated_posts.outputs IS 'Platform-specific formatted outputs (LinkedIn post, Twitter thread)';
COMMENT ON COLUMN public.generated_posts.quality_score IS 'Overall quality score 0-100 based on voice match, specificity, and slop detection';


-- ============================================================================
-- TRIGGER FUNCTION: Auto-update updated_at column
-- Automatically sets updated_at to current timestamp on any row update
-- ============================================================================

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION public.update_updated_at_column IS 'Trigger function to auto-update updated_at timestamp on row updates';

-- Apply trigger to profiles table
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Apply trigger to voice_profiles table
CREATE TRIGGER update_voice_profiles_updated_at
  BEFORE UPDATE ON public.voice_profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Apply trigger to generated_posts table
CREATE TRIGGER update_generated_posts_updated_at
  BEFORE UPDATE ON public.generated_posts
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


-- ============================================================================
-- TRIGGER FUNCTION: Auto-create profile on user signup
-- Creates a profile row when a new user signs up via Supabase Auth
-- ============================================================================

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email)
  VALUES (NEW.id, NEW.email);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION public.handle_new_user IS 'Trigger function to auto-create profile when user signs up';

-- Trigger on auth.users insert
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- ============================================================================
-- SECURITY NOTES (for Phase 2: RLS)
-- ============================================================================
-- 
-- After this migration, run 002_rls_policies.sql to:
-- 1. Enable RLS on all tables:
--    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
--    ALTER TABLE public.voice_profiles ENABLE ROW LEVEL SECURITY;
--    ALTER TABLE public.generated_posts ENABLE ROW LEVEL SECURITY;
-- 
-- 2. Create policies for each table ensuring users can only access their own data:
--    - SELECT: WHERE auth.uid() = user_id (or id for profiles)
--    - INSERT: WHERE auth.uid() = user_id
--    - UPDATE: WHERE auth.uid() = user_id
--    - DELETE: WHERE auth.uid() = user_id
--
-- IMPORTANT: Until RLS is enabled, these tables have NO access restrictions!
-- ============================================================================
